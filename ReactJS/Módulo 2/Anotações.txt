Aula 01 - Estrutura com create-react-app

Criando aplicação com o create-react-app.

yarn create reat-app nome_do_aplicativo --template typescript

Por padrão ele cria uma aplicação utilizando o JavaScript por isso o template typescript.

Para inicializar o projeto com o ract-app usa-se o yarn start

export function x export default function 

Quando se passa uma função como export default quem define o nome do componente não é quem faz a exportação e sim quem importa, ou seja, caso eu faça uma alteração no nome da exportação vai ser permitido não será a mesma da função.
Quando se exporta normalmente é obrigatório utilizar o nome da função entre { }. Caso seja necessário nomear de forma diferente ta função é só utilizar o **as** EX:

import { App **as** Batata } from './App'

-------------------------------------------------------------------------------------------
Aula 02 - Exportando assets do Figma

link do projeto no figma: https://www.figma.com/file/qkFLgkbDJdddx8T0uIligU/dtmoney---Ignite?node-id=0%3A1

Se exporta como SVG imagens vetorizadas;
o favicon é o ícone da página;

Uma boa prática para se fazer é pegar todas as cores dominantes do projeto e transformar em varáveis para se trabalhar de uma melhor forma.

-------------------------------------------------------------------------------------------
Aula 03 - Instalando Styled Components

Documentação => https://styled-components.com

Uma das maiores estratégias no front-end no quesito estilização é o css in js. Existes várias bibliotecas que fazem esse trabalho porém uma das melhores é a styled-components, para instalar no projeto se utiliza:

yarn add styled-componets

yarn add @types/styled-components -D => integração com typescript

Com o styled-components os componentes são previamente estilizados.


Para se criar faz da seguinte maneira:

import styled from "styled-components";

const Title = styled.h1`
  font-size: 64px;
  color: #8257e8

`

export function App() {
  return (
    <div className="App">
      <Title>Hello World!</Title>
    </div>
  );
}

As estilizações utilizando o styled-components nunca serão compartilhadas como ocorre no scss ou css, a não ser que seja configurado para isso.

-------------------------------------------------------------------------------------------
Aula 04 - Criando estilos globais

Para se estilizar com o styled-components cria-se um arquivo .ts dentro da pasta styles e importa a biblioteca:

import { createGlobalStyle } from "styled-components"; => estilização global.

Os componentes são nomeados com camelcase => GlobalStyle <= porque é importado como componente no react.

Por questão de acessibilidade não se remove o outlined globalmente da aplicação, porque ele define qual o elemento em foco e etc.

É importante também utilizar varáveis na criação da estilização, pois elas dão uma leitura melhor para o código. EX:

import { createGlobalStyle } from "styled-components";

export const GlobalStyle = createGlobalStyle`
  :root {
    --background: #f0f2f5;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background: var(---background);
  }
`

-webkit-font-smoothing: antialiased;  => remove o serrilhamento das fontes.

1 REM = tamanho do font-size da página, ou seja:

font-size = 16px -> 1rem = 16px

Criação de acessibilidade na página: 

 html {
    @media (max-width: 1080px){
      font-size: 93.75%;
    }

    @media (max-width: 720px){
      font-size: 87.5%;
    }
  }

Isso faz com que as fontes se adaptem para a tela do usuário e também possa deixar o uso das REM's no futuro mais simples. Se utiliza em percentagem justamente para se adaptar as configurações já dispostas no dispositivo do usuário, assim adaptando a cada um.

Tudo que estiver desabilitado na página pode ser configurado utilizando a seguinte tag:

[disabled]{
    opacity: 0.5;
    cursor: not-allowed;
  }

-------------------------------------------------------------------------------------------
Aula 05 - Fontes do Google Fonts

Os preconnect's coloca-se no incio de tudo no index.html 

<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    .
    .
    .

O input, textarea e o button por padrão não importam a font do body, por isso tem explicitar na configuração.

-------------------------------------------------------------------------------------------
Aula 06 - Componente: Header

Para ter um resultado melhor, cria-se primeiro o esqueleto do componente para depois estiliza-lo. 

É possível de forma sucinta analisar um layout e dele tirar quantas, div's terá, button e etc. Então é sempre bom analisar o layout que estamos trabalhando para saber como construir a nossa estrutura.

A tag filter cria um filtro em aul elemento e aplica uma interação, normalmente se utiliza em botões, nesse caso quando o mouse passar por cima vai aplicar esse filtro, que é um escurecimento no botão de 0.9 e o transition faz uma transição entre o estado atual e o futuro.

transition: filter 0.2s;

&:hover {
      filter: brightness(0.9)
    }

-------------------------------------------------------------------------------------------
Aula 07 - Componente: Summary

Para estilização de containers lado a lado, pode-se utilizar tanto o grid quanto o flex, mas o grid é melhor.
Repete as colunas 3 vezes com 1 de espaçamento.

grid-template-columns: repeat(3, 1fr);

o repeat(quantidades_de_vezes_para_repetir, colunasfr) serve para repetir um conteúdo uma determinada vez

-------------------------------------------------------------------------------------------
Aula 08 - Componente: TransactionsTable

border-spacing: 0 0 0.5rem; => cria uma espaçamento entre os itens de uma tabela.

Configura o primeiro filho de um pai.

&.:first-child {
        
      }

-------------------------------------------------------------------------------------------
Aula 09 - Criando front-end sem back-end

Existem muitas ferramentas que podem simular uma back-end para continuar o desenvolvimento, elas nunca serão utilizadas para produção apenas teste e desenvolvimento como:

JsonServer => cria rotas baseadas em um db.json;
MirageJS => possui bancos de dados integrados, relacionamentos e etc;
MSW => Ele adiciona um funcionamento fictício para a camada de network;


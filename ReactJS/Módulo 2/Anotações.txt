Aula 01 - Estrutura com create-react-app

Criando aplicação com o create-react-app.

yarn create reat-app nome_do_aplicativo --template typescript

Por padrão ele cria uma aplicação utilizando o JavaScript por isso o template typescript.

Para inicializar o projeto com o ract-app usa-se o yarn start

export function x export default function 

Quando se passa uma função como export default quem define o nome do componente não é quem faz a exportação e sim quem importa, ou seja, caso eu faça uma alteração no nome da exportação vai ser permitido não será a mesma da função.
Quando se exporta normalmente é obrigatório utilizar o nome da função entre { }. Caso seja necessário nomear de forma diferente ta função é só utilizar o **as** EX:

import { App **as** Batata } from './App'

-------------------------------------------------------------------------------------------
Aula 02 - Exportando assets do Figma

link do projeto no figma: https://www.figma.com/file/qkFLgkbDJdddx8T0uIligU/dtmoney---Ignite?node-id=0%3A1

Se exporta como SVG imagens vetorizadas;
o favicon é o ícone da página;

Uma boa prática para se fazer é pegar todas as cores dominantes do projeto e transformar em varáveis para se trabalhar de uma melhor forma.

-------------------------------------------------------------------------------------------
Aula 03 - Instalando Styled Components

Documentação => https://styled-components.com

Uma das maiores estratégias no front-end no quesito estilização é o css in js. Existes várias bibliotecas que fazem esse trabalho porém uma das melhores é a styled-components, para instalar no projeto se utiliza:

yarn add styled-componets

yarn add @types/styled-components -D => integração com typescript

Com o styled-components os componentes são previamente estilizados.


Para se criar faz da seguinte maneira:

import styled from "styled-components";

const Title = styled.h1`
  font-size: 64px;
  color: #8257e8

`

export function App() {
  return (
    <div className="App">
      <Title>Hello World!</Title>
    </div>
  );
}

As estilizações utilizando o styled-components nunca serão compartilhadas como ocorre no scss ou css, a não ser que seja configurado para isso.

-------------------------------------------------------------------------------------------
Aula 04 - Criando estilos globais

Para se estilizar com o styled-components cria-se um arquivo .ts dentro da pasta styles e importa a biblioteca:

import { createGlobalStyle } from "styled-components"; => estilização global.

Os componentes são nomeados com camelcase => GlobalStyle <= porque é importado como componente no react.

Por questão de acessibilidade não se remove o outlined globalmente da aplicação, porque ele define qual o elemento em foco e etc.

É importante também utilizar varáveis na criação da estilização, pois elas dão uma leitura melhor para o código. EX:

import { createGlobalStyle } from "styled-components";

export const GlobalStyle = createGlobalStyle`
  :root {
    --background: #f0f2f5;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background: var(---background);
  }
`

-webkit-font-smoothing: antialiased;  => remove o serrilhamento das fontes.

1 REM = tamanho do font-size da página, ou seja:

font-size = 16px -> 1rem = 16px

Criação de acessibilidade na página: 

 html {
    @media (max-width: 1080px){
      font-size: 93.75%;
    }

    @media (max-width: 720px){
      font-size: 87.5%;
    }
  }

Isso faz com que as fontes se adaptem para a tela do usuário e também possa deixar o uso das REM's no futuro mais simples. Se utiliza em percentagem justamente para se adaptar as configurações já dispostas no dispositivo do usuário, assim adaptando a cada um.

Tudo que estiver desabilitado na página pode ser configurado utilizando a seguinte tag:

[disabled]{
    opacity: 0.5;
    cursor: not-allowed;
  }

-------------------------------------------------------------------------------------------
Aula 05 - Fontes do Google Fonts

Os preconnect's coloca-se no incio de tudo no index.html 

<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    .
    .
    .

O input, textarea e o button por padrão não importam a font do body, por isso tem explicitar na configuração.

-------------------------------------------------------------------------------------------
Aula 06 - Componente: Header

Para ter um resultado melhor, cria-se primeiro o esqueleto do componente para depois estiliza-lo. 

É possível de forma sucinta analisar um layout e dele tirar quantas, div's terá, button e etc. Então é sempre bom analisar o layout que estamos trabalhando para saber como construir a nossa estrutura.

A tag filter cria um filtro em aul elemento e aplica uma interação, normalmente se utiliza em botões, nesse caso quando o mouse passar por cima vai aplicar esse filtro, que é um escurecimento no botão de 0.9 e o transition faz uma transição entre o estado atual e o futuro.

transition: filter 0.2s;

&:hover {
      filter: brightness(0.9)
    }

-------------------------------------------------------------------------------------------
Aula 07 - Componente: Summary

Para estilização de containers lado a lado, pode-se utilizar tanto o grid quanto o flex, mas o grid é melhor.
Repete as colunas 3 vezes com 1 de espaçamento.

grid-template-columns: repeat(3, 1fr);

o repeat(quantidades_de_vezes_para_repetir, colunasfr) serve para repetir um conteúdo uma determinada vez

-------------------------------------------------------------------------------------------
Aula 08 - Componente: TransactionsTable

border-spacing: 0 0 0.5rem; => cria uma espaçamento entre os itens de uma tabela.

Configura o primeiro filho de um pai.

&.:first-child {
        
      }

-------------------------------------------------------------------------------------------
Aula 09 - Criando front-end sem back-end

Existem muitas ferramentas que podem simular uma back-end para continuar o desenvolvimento, elas nunca serão utilizadas para produção apenas teste e desenvolvimento como:

JsonServer => cria rotas baseadas em um db.json;
MirageJS => possui bancos de dados integrados, relacionamentos e etc;
MSW => Ele adiciona um funcionamento fictício para a camada de network;

-------------------------------------------------------------------------------------------
Aula 10 - Configurando MirageJS

yarn add miragejs 

Foi colocado no componente de transação a rota para a api:

useEffect(() => {
    fetch('http://localhost:3000/api/transactions') => rota fictícia da API;
    .then(response => response.json())
    .then(data => console.log(data)) => ver se o resultado foi postado.
  }, [])

Futuramente quando o back-end ficar pronto pode-se mudar o endereço para o correto.

No index.jsx da aplicação, cria-se as rotas e também a importação do miragejs.

import { createServer } from 'miragejs'

createServer({
  routes(){
    this.namespace = 'api' => Cria a rota raiz da aplicação

    this.get('/transactions', () => { => Cria uma rota na aplicação que foi configurada anteriormente no useEffect.
      return [
        {
          id: 1,                   |
          title: 'Transaction 1',  |
          amount: 400,             |
          type: 'Deposit',         | => conteúdo que vai ser exibido no array, quando a requisição for feita.
          category: 'Food',        |
          createdAt: new Date()    |
        }
      ]
    })
  }
})

Se aparecer código 200 no console o retorno foi um sucesso.

-------------------------------------------------------------------------------------------
Aula 10 - Configurando cliente do Axios
O fetch não será utilizado para fazer a sincronização com a rota e sim o Axios, já que é uma biblioteca especializada nisso.

yarn add axios

Para configurar o axios cria uma pasta no src chamada de services. O services ele possui o intuito de ser um serviço de dados ou seja onde se pode buscar dados, enviar dados e fazer todo esse processo.
A criação da API base será assim:

import axios from "axios";

export const api = axios.create({
  baseURL: 'http://localhost:3000/api', => url padrão de todas as requisições.
})

logo após eu volto no meu TransactionsTable e altero o useEffect:

useEffect(() => {
    api.get('/transactions')
    .then(response => console.log(response.data))
  }, [])

Ao invés de ser fetch, agora se torna api.get() porque eu estou pegando o conteúdo da requisição e também não será mais necessário fazer a requisição de mudança para json. 

-------------------------------------------------------------------------------------------
Aula 11 - Configurando modal de criação
Documentação react-modal: https://github.com/reactjs/react-modal

Para instalar a biblioteca do modal se utiliza:

yarn add react-modal

yarn @types/react-modal -D

O primeiro passo para a configuração de um modal é saber qual botão será clicado para a abertura dele. No caso da aplicação desse módulo é a de Nova Transação. 
Para a configuração de um modal primeiro cria-se uma constante para ver se o modal está aberto ou fechado;
Após cria-se uma função para mudar o valor de abertura do modal para true;
Após cria-se uma função para mudar o valor de fechamento do modal para false;
É necessário um botão que executará o openModal.
E por ultimo o modal configurado a baixo do botão onde ficará os estados e propriedades do modal como o isOpen e etc.

Ex de configuração básica do modal:

import { useState } from 'react'
import Modal from 'react-modal'
import logoImg from '../../assets/logo.svg'

import { Container, Content } from './styles'

export function Header() {
  
  const [isNewTransactionModalOpen, setIsNewTransactionModalOpen] = useState(false)

  function handleOpenNewTransactionModal(){
    setIsNewTransactionModalOpen(true)
  }

  function handleCloseNewTransactionModal(){
    setIsNewTransactionModalOpen(false)
  }

  return (
    <Container>
      <Content>
        <img src={logoImg} alt="dtmoney" />
        <button type="button" onClick={handleOpenNewTransactionModal}>
          Nova Transação
        </button>
        <Modal 
        isOpen={isNewTransactionModalOpen} 
        onRequestClose={handleCloseNewTransactionModal}
        >
          <h2>Cadastrar informação</h2>
        </Modal>
      </Content>
    </Container>
  )
}

Para ficar mais semantico o modal faz parte do app, então será necessário fazer a migração do conteúdo do modal para a o App.tsx
todas as funções e o modal serão migrados exeto o button que continuará no componente Header, já que a ação de aberdura é no cabeçalho mas o conteúdo do modal semanticamente faz parte do app. Após isso para conseguir pegar o conteúdo do botão clicado no Header usa-se as props para passar isso para o modal no app.tsx. O componente header agora possúi uma tipagem:

**interface HeaderProps {
  onOpenNewTransactionModal: () => void
}**

export function Header(**{onOpenNewTransactionModal}: HeaderProps**) {

  return (
    <Container>
      <Content>
        <img src={logoImg} alt="dtmoney" />
        **<button type="button" onClick={onOpenNewTransactionModal}>**
          Nova Transação
        </button>
      </Content>
    </Container>
  )
}

E no App.tsx ficará configurado da seguinte maneira:

import Modal from 'react-modal'
import { Dashboard } from "./components/Dashboard";
import { Header } from "./components/Header";
import { useState } from "react";

import { GlobalStyle } from "./styles/global";


export function App() {
   
  const [isNewTransactionModalOpen, setIsNewTransactionModalOpen] = useState(false)

  function handleOpenNewTransactionModal(){
    setIsNewTransactionModalOpen(true)
  }

  function handleCloseNewTransactionModal(){
    setIsNewTransactionModalOpen(false)
  }
  
  return (
    <>
      **<Header onOpenNewTransactionModal={handleOpenNewTransactionModal}/> ** => Pegando a props do Header e passando para a função de abertura

      <Dashboard />

      <Modal 
        isOpen={isNewTransactionModalOpen} 
        onRequestClose={handleCloseNewTransactionModal}
        >
          <h2>Cadastrar informação</h2>
      </Modal>

      <GlobalStyle />
      
    </>
  );
}
